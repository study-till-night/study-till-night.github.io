[{"title":"mybatis一对一映射","date":"2021-09-22T14:10:10.000Z","url":"/2021/09/22/mybatis%E4%B8%80%E5%AF%B9%E4%B8%80%E6%98%A0%E5%B0%84/","tags":[["java","/tags/java/"],["mybatis","/tags/mybatis/"],["javaweb","/tags/javaweb/"]],"categories":[["IT","/categories/IT/"],["Java","/categories/IT/Java/"]],"content":"mybatis的单表CRUD我们都很熟悉，操作起来也很简单，但涉及多表连接查询这类复杂查询，mybatis有相应的标签用于处理表与表之间的映射关系。这里给出5种方式。 首先来看一下形成一对一关联关系的两个表userinfo和address，一个userinfo只对应一个address。 -extends继承关联 使用extends属性对userinfoResultMap映射表进行扩展，扩展的映射部分的id是关联表的主属性。 -原始方式 直接对两个表的所有列都一一进行映射，较为原始的方式，易于理解可读性好但配置繁琐。 -association属性 在映射结果集中使用association标签对关联表进行整体映射，property是重命名后的domain类名，将先前配置好的单表结果集作为附加与另一个表进行关联。 -使用JavaType进行关联 此种方法也使用到association标签，在association标签中使用JavaType属性进行关联而非直接使用单表的结果集，此种方式在已经配置好了单表结果集的情况下不建议使用，代码冗余。 -SELECT结果作关联属性 此类方法同样使用association标签，但在标签中采用select属性以查询的结果集作为关联属性，但注意到下面的select标签已经将查询结果转换为address结果集，说明结果集已配置，在结果集已配置的情形下该方法与第三种方式相比略显饶人，不如其简练。"},{"title":"vue父子组件通信","date":"2021-09-15T04:20:23.000Z","url":"/2021/09/15/vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"],["vue","/tags/vue/"]],"categories":[["IT","/categories/IT/"],["前端","/categories/IT/%E5%89%8D%E7%AB%AF/"]],"content":"-父传子在给vue实例添加组件后可以在html代码里使用定义的组件标签，来进行代码的复用。但倘若我们从接口获取了一些数据传递给了vue实例，想要在子组件中对它们进行展示，子组件并不能获取到这些数据，这就需要将vue实例中的data向下传递给子组件，也就是父传子了。 父传子通过在子组件的props属性中添加数据配置来实现。talk is cheap，show you the code。 props中的nlist即是用来接收父级传递下来的信息的数据对象，这里以接收数组类型为例，可以为对象配置数据类型，默认值，必要性等。注意对象的名称不必与父级传递的变量名相等，可以自定义。 接下来我们就来测试将vue实例中的list变量传递给子组件的nlist。 在body中写上一个定义好的vue1标签，该标签将被替换为注释掉的template中的内容。注意到，vue1标签内使用 :nlist=&quot;list&quot; 这是vue框架对标签属性赋值的方式，它将vue实例中的list变量赋值给了子组件中的nlist对象。结果如下图： 可以看到浏览器成功的将vue实例中的list数组渲染到了网页中，说明父传子测试成功。 -子传父在子组件触发事件时，有些情况需要我们将事件向上传递给父级处理，比如用户点击了换肤按键，vue需要将该事件及相应的数据传递给父级，由父级来进行全局的换肤效果。 事件处理的子传父使用$emit关键字，如下代码所示： 上述代码将组件内button标签的点击事件的处理函数命名为btnclick并在组件的methods属性中进行处理，btnclick存在一个参数，在函数体内通过： 向上传递。$emit第一个参数是该事件名称，父级会将传递上来的函数看做一个不同与click等基本事件的新事件，事件名即为第一个参数的值，该值可以自行定义。后面根据需要传入参数，参数个数不必与子组件的事件处理函数的参数个数一致。 接下来在html中进行测试。 为了讲解方便将vue实例单独拿出来与html放在一起。 在vue标签中我们将刚刚传递来的upclick事件交给accept函数处理，accept函数便是在vue实例中实现功能，而非子组件。 这里顺便讲一下子组件将变量传递给父级的方式，即通过ref关键字。在上述代码中可以看到， 这行代码，通过ref关键字为此独立的子组件起一个名字，然后父级就可以简单的使用： 获取子组件的变量了，需要注意的是，能获取的只有为其命名过的子组件其他无名组件的变量是无法得到的。这与事件的传递不同，事件传递对所有子组件实例都生效。 结果如下图： 依次点击三个按钮后，可以看到accept事件处理函数成功打印了传递上来的字符串及子组件的数组变量。"},{"title":"cli原理理解-webpack手动配置(2)","date":"2021-09-08T12:27:18.000Z","url":"/2021/09/08/cli%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3-webpack%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE-2/","tags":[["IT","/tags/IT/"],["前端","/tags/%E5%89%8D%E7%AB%AF/"],["webpack","/tags/webpack/"]],"categories":[["IT","/categories/IT/"],["前端","/categories/IT/%E5%89%8D%E7%AB%AF/"]],"content":"-续前篇在上一篇webpack博客中我们已经成功将所有js文件都打包成了一份bundle.js文件，但有一个明显的问题是，一个web应用不可能只有js代码，css和图片等静态资源呢？它们是否能同样被webpack打包？ 你可以尝试书写一个简单的css文件，并在main.js中引用它。 再次npm run build后，发现webpack报错了，错误原因是无法识别normal.css这个文件。这样就显而易见了，css文件的打包不简单等同于JavaScript文件。 所以接下来就要引入新的名词，webpack中的 loader。 -css及Less的打包要想打包css，我们需要下载打包css专用的css-loader，并在webpack.config.js中进行相应的配置。 安装css-loadernpm install --save-dev css-loader 这里注意要安装和你当前局部webpack适配的css-loader版本。我们可以去github搜索css-loader，找到下图的项目。 进入后在左侧master分支下找到tags，里面是当前项目历史所有的版本，随便点开一个版本，找到该版本的package.json devDependencies,查看其所依赖的webpack版本。比如下图： 代表这个版本的css-loader需要依赖4.26.1及以上版本的webpack。这算是一个预先解决版本适配的问题的方法，当需要查询其他模块版本适配问题时同样可以采取这个办法。 安装完后在webpack.config.js中进行配置在module.exports中添加下列代码： 以上都是规范大概知道每个属性的含义即可，不必硬记，想更为详细的了解可以直接查看官方文档。我们做项目基本用到的都是帮我们封装好的脚手架，其已经帮我们屏蔽了webpack具体的实现，这里主要是理解原理。 接下来我们再打包一次，已经不报错了，但在浏览器上打开index.html，发现css样式并没有生效。这是为什么？ -style-loadercss-loader的作用其实只是将css文件打包，但它并不帮助我们进行样式的渲染。渲染的工作由另一个loader——style-loader负责。所以我们接下来进行同样的操作。 npm install --save-dev style-loader 并修改webpack.config.js文件： 这会再次执行打包命令并打开index.html，发现样式已经生效了。 Less打包Less文件的打包同理，举一反三即可。先安装，后配置。 $ npm install less less-loader --save-dev -静态资源的打包关于静态资源的打包，webpack5.x系列版本较先前有了较大的革新。摈弃了loader的方式，不再采用url-loader、file-loader, 而是使用自带的asset模块方式进行打包，无需额外下载。 这里将两种方式都给出来，可以做一个比较和参考。 file-loader方式如今webpack5官方文档已经移除了file-loader的说明，只能在webpack4中找到。首先进行安装 $ npm install file-loader --save-dev 在webpack.config.js中添加 注意代码段中末尾的 type: &#39;javascript/auto&#39; 一定要添加，不然file-loader会与webpack5的asset发生冲突，无法正确展示图片。 options中可以有很多属性，常用的大概也就上述所列的几种。其他的在官方文档都有说明。 默认asset模块方式webpack5默认的asset模块方式不用安装或配置也能对静态资源进行打包，但使用起来难免有所局限，对其进行特性化的配置还是有必要的。 虽然两者都能够完成静态资源打包的工作，但我们还是推荐使用最新的方式，可以看到asset免去了安装loader的步骤，缩减了配置成本，这也许是后面webpack更新的一种趋势。 -plugin的配置示例查看官方文档有很多plugins的说明，我们这里拿一个比较实用的HtmlWebpackPlugin当作示例。 这个插件的作用是什么呢？我们注意到webpack打包时是不会将index.html也打包进dist的，然而dist文件夹应当是包含项目所有资源文件的整合包，所以目前的dist包显然是不完整的。HtmlWebpackPlugin的作用就是将index.html也加入到dist包中。接下来我们来看操作步骤。 npm install --save-dev html-webpack-plugin 之后在webpack.config.js头部进行导入 在module.exports中添加 配置好上述信息后，我们就可以把index.html中 这行标签删除了，webpack会在打包时帮自动我们引入bundle.js文件，怎么用，是不是很方便？其余的插件都是安装后通过模块化导入，在plugins数组中new个新对象即可，大同小异。 -devServer为了方便开发人员使用webpack时的实时调试，webpack提供了devServer，即程序员口中常说的热加载。如果你使用vscode书写前端代码，那么你一定用过liveServer这个插件。这两者在本质上是相近的，它们在启动后可以实时响应你对源文件的修改。 配置很简单，只要在module.exports中加入 并在package.json中加入自定义脚本命令 此时输入npm run dev 后稍等片刻服务就会启动并打开网页，你可以尝试修改index.html或main.js中的内容，你会发现页面也发生了相应的修改。 这里要提一点的是，运行devserver时你的源文件并没有真正的被打包到dist文件夹，它们暂时被保存在内存中以提高开发效率，真正进行打包还需要执行npm run build 命令，不信你删除dist文件夹后启动devServer，你会发现并没有dist文件夹生成。 -总结篇幅有限只能讲解一些浅显的webpack配置，要想把webpack吃透是要下很多功夫的。但我们要知道的是，一般我们做业务不从事研究岗，要秉承一个原则，边学边用，当我们需要的时候再去学习，不需要将所有、100%的知识都学会，因为常用的可能无非也就那10%，这样学习成本太大，实用意义也不高。"},{"title":"cli原理理解-webpack手动配置","date":"2021-09-02T04:23:17.000Z","url":"/2021/09/02/cli%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3-webpack%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"],["webpack","/tags/webpack/"]],"categories":[["IT","/categories/IT/"],["前端","/categories/IT/%E5%89%8D%E7%AB%AF/"]],"content":"-简单的食用说明! important—— 使用webpack需要你拥有前端模块化的知识。 我将分两章对webpack的手动配置，从目录结构到一系列loader到plugins的搭建进行说明。有人觉得学习webpack手动配置毫无意义，因为vue之类的框架已经帮你封装好了一切并称之结果为cli(command line interface)，即俗称的脚手架。 但要知道这些cli的实现基础就是webpack的配置，即对webpack.config.js文件的处理，理解手动配置webpack的原理可以更好的掌握脚手架的应用。 由于水平有限，若有阐述错误或难以理解的情况望多多包涵。 -webpack目录结构众所周知，上手一个开发工具首先要了解它的目录结构，如果连项目里每个文件夹是做什么的都不造，那怎么可能使用的好。首先给出一个最为简单的模板： 根目录下有dist,node_modules,src三个文件夹，分别存放打包后的js文件和静态资源、node依赖包和源文件。src中根据需要可以创建css,js,vue,img等子文件夹。 根目录下另外还有两个文件webpack.json和webpack.config.js 。其作用在下文进行说明。 src目录下的index.html是网站的入口文件，用于引用打包好的js文件。main.js是webpack的入口文件，在webpack进行打包后该js文件内部直接或间接引用的模块都会被打包进最终的结果。（未被任何js文件引用的模块js文件不会被打包） 注意: 这些文件夹都是手动创建的，webpack只会把打包的文件放到dist中。文件夹名不一定非要和图中一致，路径都是在webpack.config.js中手动配置的，不过一般都是如此约定俗成。 -创建package.json在开始一项工程前，创建一个package.json文件是必须的。这个文件有什么用呢？它包含了你在做的或者你接手的项目的名称、概要、作者、证书、依赖的node包和脚本命令等一系列信息。 最重要的，有了这个文件你或你的同事就不用将本地的所有node_modules包文件都发布到远程仓库上，因为只需执行npm install npm就会依照package.json中的依赖将项目所需的包下载到你的电脑上。 要想创建package.json，只需在项目根目录执行npm init命令，根据终端提示输入相应的信息即可完成初始化。下面是什么都无的原始package.json内容。 等到下载了一些node包后，里面还会有dependencies及devDependencies（运行时依赖和开发时依赖）区别主要在于执行安装命令时是否有--save-dev，运行时依赖是项目发布后也需的依赖包，开发时只在开发阶段起到作用。 -局部下载webpack一般webpack都是建议局部下载的，以适配不同项目。在项目根目录下执行npm install webpack@版本号 --save-dev开发时局部下载到当前目录。下载成功后目录内会出现node_modules文件夹，同时package.json中会出现 此时是不是想着执行webpack -v来查看webpack是否安装成功？你可以试试，如果你全局安装过webpack的话，显示的将是全局版本而非刚刚下载的版本。因为在终端执行的所有命令，都是默认查找全局下载的node包的，局部的版本此时无法被识别。那有什么方法可以使用局部安装的包吗？ 注意到package.json文件中有这么几行 “scripts”包含的内容即为运行局部包的自定义命令，以npm run 命令的格式执行。通常使用局部webpack的约定俗成的命令为npm run build，所以我们在括号中添加如下代码： 其实完整的命令还需在webpack后加上入口文件、生成目录及模式，这些我们放到后文的webpack.config.js配置中细说。之后执行npm run build使用的就是局部webpack了。当然，你现在可以暂时改成 来查看本地安装是否成功。 -webpack.config.js书写webpack.config.js用于配置webpack的一些相关信息，包括入口路径、输出路径、loader配置、plugin配置、热加载等所有与webpack有关的配置。下面给出一种模板： 以上是一个webpack.config.js最基本的配置，看看注释也很好理解，主要说明一下_dirname这个参数，其实就是通过path包将自身绝对路径与相对路径进行拼接，因为webpack要求我们提供入口和输出的绝对路径。在这里就可以进行上文提到的文件夹名修改，只要配置和真实的文件夹名一致即可。 若不进行这些配置，在自定义脚本时build后就得扩充成 webpack ./src/main.js -o ./dist/bundle.js mode=development 看上去很冗杂打起来也费劲，所以在webpack.config.js中配置也是必要的。 另外，所有的配置信息都应当写在module.exports 内，很好理解，所谓js配置文件无非也就是一个模块供webpack导入并读取相应的键值对。 -打包测试完成上述所有任务就可以来测试一下打包效果了。首先在src目录下的js文件夹编写一份用做模块导出的js文件，比如export.js： 在main.js中编写测试： 在index.html中用script标签引入bundle.js。 此时在根目录下执行npm run build进行打包，完成后查看dist文件夹，发现多了一份bundle.js文件，在浏览器中打开index.html，发现调式窗口中输出相应信息。 -续目前为止我们已经完成了简单的webpack打包测试。接下来一章将讲解loader、plugin和devserver的配置，这才是真正棘手的操作，要时刻考虑版本的适配问题。请做好准备（滑稽）。"},{"title":"爬虫数据制作简易微信小程序","date":"2021-08-31T05:36:30.000Z","url":"/2021/08/31/%E7%88%AC%E8%99%AB%E6%95%B0%E6%8D%AE%E5%88%B6%E4%BD%9C%E7%AE%80%E6%98%93%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/","tags":[["IT","/tags/IT/"],["前端","/tags/%E5%89%8D%E7%AB%AF/"],["爬虫","/tags/%E7%88%AC%E8%99%AB/"],["微信小程序","/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"],["flask","/tags/flask/"]],"categories":[["IT","/categories/IT/"],["前端","/categories/IT/%E5%89%8D%E7%AB%AF/"],["爬虫","/categories/IT/%E7%88%AC%E8%99%AB/"],["微信小程序","/categories/IT/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"]],"content":"暑期实训老师最后要求做一个利用爬虫获取数据保存到数据库，自选后端语言实现接口，以微信小程序的形式作为展示的项目，正好用先前爬取好的豆瓣TOP250电影数据来完成这个任务。爬虫代码详见博客链接 爬虫。 -flask做后端接口flask是python的一个轻量级web应用框架。主体只有两个模块——路由选择和页面渲染。只为提供接口的话实现路由选择功能就足够了，因为用户界面部署在微信小程序上。 后端需要满足微信小程序发来的不同类型请求，分为按关键字查询、按排名查询、上滑按页加载。 我做的时候提供了三个接口路径后来思考一下这完全不必要。先放一下代码 w1,w2,w3路由分别对应上述三种请求，但其实完全可以合三位一，只需在微信端传入参数中加入type属性，不同请求设置type值分别为1，2，3在flask方法中接收type并判断请求类型执行相应sql查询。 -wx小程序端因为我有前端和一些vue基础，而简单微信小程序开发又与web开发几乎相差无异，理解其专有的一些标签十分轻松。而标签中内嵌的语法，js中的对象实例和传值语法与vue大同小异，上手也十分快速。首先放一张效果图： 250部电影的渲染其实就是wx-for的动态生成效果，预加载时先向flask接口请求一页（25）部电影的信息，并存进数组wx-for会自动渲染DOM树。 除截图展示外，小程序支持上滑异步加载界面，下拉刷新，电影剧组板块可上下滑动查看完整信息。但很遗憾”前往”按钮目前只能为摆设，因为微信小程序的界面跳转区别于web页面，需要在内部对前往的页面进行注册并创建相应的wxml容器否则就算链接有效点击也是无效的。250部电影必然不可能为每部都进行注册。 -wxml code 可以看到微信小程序的DOM树较web页面是更为简单的，小程序也属于移动端开发，受移动端设备限制页面不会像web端那般复杂。 -javascript code 从js的代码中更可以看出微信小程序开发与web开发的相似，无非就是事件监听，ajax异步请求，一些生命周期函数（当然index页面并没有）还有wx小程序特有的一些事件处理——触底函数、下滑刷新、用户分享等一系列函数。 在wx小程序里将css称为wxss，其实就是换汤不换药，语句书写几乎一致，用sass、less编译出的css直接使用问题都是不大的。这里就不贴css代码了，毕竟样式书写是基本功，也没什么好展示的。"},{"title":"webpack4.x及5.x安装问题","date":"2021-08-27T12:46:21.000Z","url":"/2021/08/27/webpack4-x%E5%8F%8A5-x%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/","tags":[["IT","/tags/IT/"],["前端工具","/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"]],"categories":[["IT","/categories/IT/"],["前端","/categories/IT/%E5%89%8D%E7%AB%AF/"]],"content":"-webpackwebpack作为对文件进行打包实现模块化开发的前端工具在如今十分流行。 官方解释：webpack是现代的Javascript应用静态模块打包工具。 -nodejsnodejs支持javascript脱离浏览器在服务端运行，是webpack工作的必需环境。截至日前最新版本16.8.0，下载入口 nodejs下载。 检测node环境配置：cmd中输入node -v出现下图即配置成功。 -npmnpm即Node Package Manager –node包管理工具。较新node已包含npm，同样可通过cmd中输入npm -v检测安装结果。 默认最新版npm，想更改可以通过指令 npm install -g npm@5.6.0 //假设到5.6.0 g是全局下载 ps –修改全局下载路径npm默认的下载路径在C盘，可以在cmd中输入npm g或者npm config ls -l详细查看，prefix即为你当前的路径。 虽然不影响使用，但建议还是将改路径修改到node根文件夹内方便日后管理。在根目录下新建两个新文件夹node_global及node_cache，并在cmd中进行配置 由于全局模块多在cmd中直接使用，所以需要将global文件夹添加到系统环境变量。 1.新建一个系统变量，变量名：NODE_HOME，变量值：D:\\nodejs（你node文件夹的根目录） 2.在Path变量名中，新建变量值 2.1%NODE_HOME% 2.2%NOED_HOME%\\node_modules 2.3%NODE_HOME%\\node_global 全部完成后在cmd中尝试一次全局下载，例如npm install bootstrap -g，若模块成功出现在目标文件夹下，则配置成功。 -webpack安装webpack通过npm直接在cmd输入npm install -g webpack@版本号 中安装。截至日前最新版本是5.51.1，想要确保稳定性的可以适当降低版本号，或者去官网查看vue等脚手架的推荐适配webpack版本。 这里有人可能会遇到下载速度极其缓慢的情况，这是因为npm的地址是处于国外，连接不太稳定。可以改用国内的淘宝等镜像源cnpm。网上方法很多，这里给一个链接 cnpm配置。 下载完后cmd中输入webpack -v查看webpack安装情况时，若下载版本为3.x可以直接看到结果，但4.x及以上会出现下载cli的提示，此时输入yes确定npm会报错。查看文档注意到webpack4.x以上已将cli分离为独立的包，需要额外下载，此时在cmd中输入npm install --save-dev webpack-cli -g全局开发时依赖下载即可。 再次输入webpack -v，出现如图 安装成功。"},{"title":"忧国的莫里亚蒂的优与劣","date":"2021-08-20T11:06:41.000Z","url":"/2021/08/20/%E5%BF%A7%E5%9B%BD%E7%9A%84%E8%8E%AB%E9%87%8C%E4%BA%9A%E8%92%82%E7%9A%84%E4%BC%98%E4%B8%8E%E5%8A%A3/","tags":[["动漫","/tags/%E5%8A%A8%E6%BC%AB/"]],"categories":[["动漫","/categories/%E5%8A%A8%E6%BC%AB/"]],"content":"-关于这部番 作为Production I.G制作的去年10月的一部新番，首播前就以作为柯南·道尔的著名推理小说《福尔摩斯探案集》的二改漫画作品吸引了大量福尔摩斯原作粉。全作分为上下两部分，下部分已于今年3月末首播，目前已经完结。本剧大胆创新，将福尔摩斯宿敌詹姆士·莫里亚蒂作为主角，讲述了出生就有着卓越犯罪天分的莫里亚蒂为拯救19世纪末的英国作为“犯罪卿”对高层罪恶贵族进行抹杀的故事。 -值得称道的三点 精致的作画和氛围渲染 故事内容充实 开篇华丽 主角的形象塑造丰满 从近些年的很多作品可以看出，只要肯下经费作品的画质已经基本不成问题（紫罗兰、虚构推理、奇蛋、除开剧情不谈的全员恶玉），小教授这部番当然也属于经费充足的一类，番里只要有戏份的角色形象都勾勒的十分完美。除此之外许多场景的绘制和气氛的烘托也很到位，像首集开头和黄毛贵族猎杀人类时采用的血红滤镜，都很符合这部番幽暗、诡异的基调。 小教授这部番属于单元剧穿插主线的剧情行进方式，24集的篇幅涵盖了许多不错的案件（诺亚迪克事件、火车杀人案），通过不断对主旨进行深化，引入更多的同样寄托英国未来的人物（伙伴），内容是比较充实的。小教授在剧中通过许多方式都塑造出其冷静、果断、智力过人甚至可以说是狡诈（这里当中性词）的人设，同时福尔摩斯作为伦敦表面上的正义代表，正直、感性、重义气的形象也是被详细刻画。（夏洛克多次冒危帮邦德我认为已经很能表现夏洛克的人设了） -美中不足 结局差强人意 推理元素浓度不足 配角形象不够丰满可以很明显的看出，小教授的结局是有问题的。未经过任何铺垫的夏洛克和小教授在共同除掉白毛后就云里雾里的成为了夏洛克口中的“朋友”关系，并且关系紧密到需要夏洛克与小教授对线来挽救其性命。断桥上两人的对话更是略显“暧昧”,聪明的你一定已经发觉了，这是制作社给两人强行安排的CP。暂且不说这一操作究竟是否导致本番烂尾，但确确实实是给自己涨了一波热度，详见弹幕： 大波腐女蜂拥而至，弹幕氛围乌烟瘴气。 抛开这个问题不谈，小教授的“最后一案”在逻辑上也不在理。一把乱火就瓦解了英国根深蒂固的阶级歧视，贵族平民携手共建家园，未免太过儿戏。既然如此，为何先前要效率极低的逐个铲除贵族，甚至不惜当他们的孩子的面，被他们的孩子记恨终身，极不合情理。话又说回来，在我看来夏洛克和小教授应该贯彻一种以智斗为方式的“宿敌”较量,这场博弈应该一直维持到故事的结束（而且两部分的OP里都有两人对立的场景我当时还满怀期待结局会怎么较量结果给我整个饭圈文化我属实呕了）。 要是我当编剧，会在这断桥上安排一场够精彩的打戏。夏洛克来赴约也不是为了挽救“朋友”，而是为了将阴影里实施犯罪的罪魁祸首抓获归案，绝不能让他自己选择死亡来逃避犯下的罪。夏洛克会一直贯彻内心的正义，小教授也遵循自己的罪意志，为除掉想抓获自己归案的夏洛克而与其战斗。战斗结果是夏洛克刺伤小教授，小教授坠下高空，但他已无心赴死因为他感受到了与宿敌较量的快感。 最后两人在酒吧见面这一幕可以保留，但两人是真的偶遇，小教授看到夏洛克，嘴角露出一丝微笑，夏洛克意识到后先是震惊，后无奈的一句：“切，果然我和你的较量还不能结束啊。廉。”我个人认为这样结尾还是很有感觉的（/滑稽），至少比搞男男CP好。 除此之外大哥和三弟路易斯的戏份过少，路易斯甚至直接成了凡事都叫尼桑，干活时只负责打架的工具人。大哥一把火弑亲这一行为也是饱受诟病。大哥的心里活动描写过少才导致了这种突兀感，更像是无情而非觉悟。个人觉得在三人逃出前安排一段大哥父母倒在地板上挣扎，向大哥说：“阿尔伯特，救...救我...”，大哥很纠结的咬紧了牙关，然后此时描写一下大哥内心:\"对不起，父亲、母亲，我因你们的养育而感恩，但我选择了自己的道路，而你们的罪恶导致我不得不让你们成为牺牲品，请原谅我。\"的剧情，只要这么一个场景，大哥的角色就会丰满许多，倒不至于被喷“大义灭亲”了。 -总结这部番用上面的小标题点评即值得称道但美中不足，逼格很高，主题很深刻，作画也很优美，但剧情细节还有待加强。"},{"title":"Java封装原生数据库连接及修改查询操作","date":"2021-08-19T03:45:48.000Z","url":"/2021/08/19/Java%E5%B0%81%E8%A3%85%E5%8E%9F%E7%94%9F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%8F%8A%E4%BF%AE%E6%94%B9%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C/","tags":[["IT","/tags/IT/"],["java","/tags/java/"]],"categories":[["IT","/categories/IT/"],["Java","/categories/IT/Java/"]],"content":"-SUMMARY大二暑期实习和课程老师学了下Java封装原生JDBC操作MYSQL，用BasicDataSource和线程本地化简化连接操作，用不定参数实现数据修改查询模板。JavaEE水平很有限虽然感觉很基础也很底层，但同时也认为对于日后学习spring系列框架数据库相关方面的原理是有所帮助的。 -ATTENTION 封装需要DBCP连接池jar包的支持，如果是maven项目直接去maven官网搜索DBCP复制依赖到pom.xml里即可。 -DButil Class -JDBCTemplate ClassexecuteQuery方法的第二个参数IObjectMap是自己创建的接口用于将ResultSet对象转换成泛型，调用时以lambda表达式的形式书写。接口声明及调用样例见下文。 -IObjectMap Interface -executeQuery 使用样例java8 及以上支持lambda表达式（闭包） 食用说明 "},{"title":"Vue结合axios库实现音乐播放器","date":"2021-08-12T03:55:35.000Z","url":"/2021/08/12/PLAYER/","tags":[["IT","/tags/IT/"],["前端","/tags/%E5%89%8D%E7%AB%AF/"],["vue","/tags/vue/"]],"categories":[["IT","/categories/IT/"],["前端","/categories/IT/%E5%89%8D%E7%AB%AF/"]],"content":"前几天在B站上跟着做了一个第三方接口的音乐播放器的前端网络案例MC PLAYER入口。案例是Vue基础指令与axios库get跨域请求（服务端已处理CORS问题）结合，个人还引用了Jquery来做一些动画 (毕竟CSS3动画不好学) 。有一说一，感觉就我目前的蒟蒻水平而言用Vue来填充数据Jquery做动画效果还是挺香的。图片和字体图标在本地没放图床，想本地打开的可以自由选择替换的资源。 -index文件 -样式文件我的index文件里没写CSS和JS的引入语句 想本地打开的要自己添加 -JS文件 B站原教程地址: 黑马程序员Vue4小时入门"},{"title":"钢之炼金术师FA人造人浅谈","date":"2021-08-08T12:32:42.000Z","url":"/2021/08/08/%E9%92%A2%E4%B9%8B%E7%82%BC%E9%87%91%E6%9C%AF%E5%B8%88FA%E4%BA%BA%E9%80%A0%E4%BA%BA%E6%B5%85%E8%B0%88/","tags":[["动漫","/tags/%E5%8A%A8%E6%BC%AB/"]],"categories":[["动漫","/categories/%E5%8A%A8%E6%BC%AB/"],["钢炼","/categories/%E5%8A%A8%E6%BC%AB/%E9%92%A2%E7%82%BC/"]],"content":"-写在前面对于荒木弘前不久这波操作（啥操作？懂得都懂），我的看法只有1个字——很可惜。可以说是一时脑抽毁了自己在中国的市场。但凡以一名日本漫画家的身份理性的考虑几秒，都能明白在中日关系这种敏感的地带，容不得谁肆意妄为。本人称这是为了“让那个国家的人无法再创造盗版”，这是荒谬的，站不住脚的。此类行径只会被认定为侮辱 (荒木画了啥？建国伟人成js，可以自行度娘) 而非对自己的维权，如今B站钢炼评分区水深火热一星无数，兄弟们态度显而易见。本文就只针对作品展开讨论。(荒木弘谁？不认识 /滑稽) -摘要钢炼这部作品对于主角团甚至无关剧情走向的配角的形象都能够做到细致而微妙的刻画，每位人物的出现都绝不会只是走个过场，在后文都得到了自身的一种价值体现。钢炼也是我看过的七十几部番中 (数量不算大，但也见过很多角色形象与不同的剧情)唯一一部最终决战时几乎所有出现过的配角都重新登场为战斗做出贡献的作品，当然是本身有战斗能力的 (哈伯克、罗斯、蕾贝卡、法尔曼、爱德师傅等很多)。决战时忍痛射伤布拉德雷的小兵也令我印象深刻。 本文就七位人造人的形象做一个粗浅的概要与分析。人造人作为钢炼中反派主要战力，是瓶中小人为摆脱七宗罪而诞下的产物。可以这么说，每个人造人的诞生都不该是他们自己的本意，而是一场悲剧。 -正文 -拉斯特lust在09版FA中的戏份极少，是第一位领盒饭的人造人，被大佐烈火焚烧挂的很惨，人物性格也没有过多的展现。但在03版钢炼中对lust的刻画更为细致。作为scar哥哥炼成恋人的失败品，lust被但丁改造成人造人。中期被感化激发出了内心想成为真正人类的渴望，动画中对她的这个想法也进行了细致的描述，后被人造人同伴所杀，并没有获得自己想要的人生，在不甘与遗憾中死去。 -格拉托尼 gluttony作为以生吞这种残暴杀人行径为攻击方式的人造人，性格却是异常单纯。以吞食作为本能，没有什么自己的想法，总是流着口水说着“能吃🐎”这种单纯的询问。作为人造人，gluttony不能称之为恶（全剧只有2个极恶不带一点白的，仔细想想应该可以知道），只是他被赋予的天性逼迫着他不断吞食他人，他对lust的依恋、为了替lust报仇展开伪真理之门也展现出gluttony作为人造人拥有的情感与羁绊。最后惨被同伴吞噬，暴食最终被他人吞食，算是一种讽刺。如果gluttony是个普通的人类小胖子，也许真很能赢得他人的喜爱。 -普莱德 人造人老大，七宗罪里的最强战力。生性冷酷，凶残。 持有孩童的外表（准确说是容器），性情却异常沉着与冷静（和阿尔一起被困时还能想到用摩斯电码）。如此不贴合外表的内心，本体却是刚出生的婴儿。自诞生来一直在与安排的家庭扮演安排的剧情，pride打心底是想拥有真正亲情的。 pride在剧中有原话，母亲是让他体会到人类温暖爱意的人。最后也是给安排了一个温馨的结局，在母亲的呵护下重新成长为善良有爱心的孩子，真正作为孩童而存在。 -斯洛斯名为懒惰的人造人，却在地底下默默无闻的挖洞几百年，最后辛勤的战斗至死，对sloth也许这几句话就已经很透彻了吧。 -恩维 前期的形象完全是一个纯正的反派。生性极其狡诈，依赖其拿手的易容术先是在伊修巴尔挑起纷争，后又变成休斯妻子将其杀害，一脸油嘴滑舌，看的很令人火大。但本人在摘要中已提过，每个人造人的诞生都是一场悲剧，envy也不意外。后期也是在一集中安排了几分钟的特写镜头来剖析envy不轻易向人吐露的内心，他嫉妒人类，能在彼此依旧怀有仇恨的情形下依旧平安的相处，人类的这种理性，作为同伴的互相依靠与信赖，envy打心底嫉妒。在爱德华怀着悲悯的神情指出这点后，桀骜不驯的envy终于带着被理解的慰藉化为尘土离去。envy算是人造人中十分贯彻自己称呼的一位了。 -拉斯 唯一会随年龄变大而老去的人造人，亚美斯多利斯大总统，这位人造人也有很多值得分析的地方。本就孤儿出生的金·布拉德雷（其实无论谁当上总统都是这个名字，现在的wrath应该是无名无姓的）被拉进大总统生成基地，与其他同样尚不知事就来到此地的孩子一样，接受着残酷与严格的训练。 布拉德雷在基地里学习帝王学，比拼剑术，甚至刺伤他人也美曰：“他们只会成为你前进的垫脚石。”此时的布拉德雷仍不知这地狱的真相，直到他躺上了手术台，被注射贤者之石。金·布拉德雷诞生了。走出地狱的wrath被安排成为大总统。 wrath选择了自己现在的妻子，并被安排pride作为二人的养子。在外凭借最强之眼杀敌无数的大总统，在家庭里也有作为人类丈夫和蔼的一面。这就是这个人物的双面性。他虽然对妻子隐瞒了自己身份的秘密，但他对妻子绝不乏作为人类的爱意与关怀。除此之外，wrath作为拥有半个人类血统的人造人，有着人类宝贵的理性，这份理性使其能与大佐、艾尔利克兄弟甚至霍克艾中尉面对面谈论人造人的事情而非见面就拔刀相见。 只可惜，正如wrath自己所言，他的一生都在安排好的轨道上行驶，所作的一切都是为了那位大人，容不得自己的选择。在决战中，所向无敌的大总统最终倒在自己践踏过的伊修巴尔人脚下，结束了自己早已被固定好的命运。在弥留之际，他没能见到一直担心着自己的妻子，但他很释然，“多亏了你们人类，让我的一生有了些许意义”，说完这句话，亚美斯多利斯大总统闭上了双眼。愤怒终归平静。 -格利德 全局戏份最多的人造人,没有之一，同时也是唯一个帮主角帮打自己人的人造人。格利德这个角色的形象塑造的十分丰满立体，人格魅力浓厚，详细说来可能难以控制篇幅，故挑些重点来分析。这里所讲的greed指二代greed，前代greed出场没多久就被小人给炼成汤领盒饭了，但他当时的同伴中蜥蜴人的存活给后文二代格利德的叛变埋了个伏笔。 greed天性并不凶残，相反他或许是最容易沟通的人造人，从未主动向主角帮动手，每次爱德呼喊麟的时候总是邪笑着用“谷粒多哒”来回应，竟有些许风度。在地下管道杀死昔日的同伴蜥蜴人后，greed心中遗留的记忆开始冲击着他的内心，驱使他盲打莽撞攻击了wrath，不得不潜逃。这里已能看出greed这个灵魂无论更换多少躯壳，同伴这个词对于其都是极具分量的存在。后被爱德邀请成为“同伴”，表面上很不乐意嚣张地反让爱德成为他的手下，但内心对于来自昔日敌人的邀请却感到向往。 greed与灵魂的同伴的磨合历程也值得玩味，刚开始入侵麟身体时的嚣张与霸道因麟的欣然接受转为“感到有趣”,在杀死过往同伴时被麟指责开始认识自己，在与pride战斗时相互切换发挥配合各自优势，俨然一对完美的搭档（greed认为麟和自己一样有着贪婪的人格）。到最后为保护麟，立过“我绝不说谎”这个flag的greed说了他人生的第一个谎也是最后一个谎，在共同战斗的同伴的不舍的目视下，带着拥有同伴的满足，不留遗憾的化为尘埃而去。桀骜不驯，渴望获得一切的贪婪，最终归于满足。 -总结每个人造人的诞生都是一个错误。有的人只遵循他人的意愿，将错误进行下去；有的人贯彻自己的信念，得到了满足。审视这些人造人，或许能认识到自己人生的真正价值。"},{"title":"python爬虫初级教程","date":"2021-08-06T10:16:42.000Z","url":"/2021/08/06/python%E7%88%AC%E8%99%AB%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B/","tags":[["IT","/tags/IT/"],["爬虫","/tags/%E7%88%AC%E8%99%AB/"]],"categories":[["IT","/categories/IT/"],["爬虫","/categories/IT/%E7%88%AC%E8%99%AB/"]],"content":"-爬虫简介python爬虫就是运用python语言中强大的第三方库模拟浏览器向网站发送请求，爬取目标网站HTML源码并进行解析从而得到希望的信息的一种手段。下面以爬取豆瓣TOP250电影信息作为爬虫初级的案例。本文只以豆瓣案例为例对爬虫的基本流程做大致归纳，代码详细含义还请另外查找教程。 -所需第三方库 urllib 模拟浏览器发出请求并接收响应 bs4 解析html代码 re 正则表达式 time 爬取间隙以休眠方式实现 xlsxwriter excel相关 pymssql 数据库相关 -主体函数 askinfo函数 获取网页源码 在浏览器调试模式下（F12）network选项， 刷新页面后立即暂停记录，选取靠前位置的记录并打开headers信息获取浏览器user-agent ，保存以备后用。缺失此步有大概率会导致爬虫被识别从而被禁止访问。 使用urllib.request.Request发送信息，参数传递为网站url、之前获取的头部、请求方式。接收反馈， read并用utf解码（注意休眠），返回解码后的html源码。 getdata函数 对爬取的源码进行分析提炼 声明html分析器的bs变量，解析askinfo函数返回的html源码。利用bs库的查找函数找到目标信息对应的html标签大致位置。运用正则表达式分别搜索不同类型的信息。（正则表达式使用re库预先进行处理） 将正则表达式返回的信息填入当前子列表,子列表入父列表,返回最终的父列表。 savedata函数 存储数据（以存入excel为例） 参数传入保存路径和getdata返回的列表，运用xlsxwriter库创建新文件的新工作表，将列表中子列表元素填入文件对应行列。最后关闭文件。成果如下。（部分） savedata函数（以存入数据库为例） 参数传入为getdata返回的列表。本文讨论存入mysql 。存入sqlserver，sqlite等数据库方式类似。 1.initdb函数 创建数据库 连接数据库，填入对应host、 user、 password、 database、 charset，连接之前在cmd输入services.msc，找到mysql的服务并启用。获取游标,编写创建表单的sql语句（建议在workbench中新建查询复制过去执行验证是否正确）。执行sql语句, 提交结果。关闭游标，关闭连接。 2.savedata函数 数据填入部分实现 对于获取到的列表中每一个子列表中的每一个子元素，进行首尾添加双引号处理，避免之后执行sql语句时产生二义。 连接数据库（同initdb函数） 编写sql插入语句，通过join函数对子列表每一个元素用逗号分割，将整个子列表用%s方式传入sql语句中，执行sql语句，上传结果。关闭游标，关闭连接。数据导入完成。 使用python爬虫爬取豆瓣top250电影信息工作完成 -ps：数据可视化内容可自行了解 若只为获取信息上述知识足以应付。若希望做出以采集信息并呈现为主打功能的网站项目，数据可视化的知识需要掌握。 一种可选的组合： python入门级web应用开发框架flask 图表框架 Echarts词云WordCloud 用于词汇出现频率处理及对应展示。 此组合为数据可视化的一类选择搭配 并非固定。有兴趣者可深入了解相关框架及应用。 "},{"title":"火影忍者里的神话背景","date":"2021-08-05T10:14:30.000Z","url":"/2021/08/05/%E7%81%AB%E5%BD%B1%E5%BF%8D%E8%80%85%E9%87%8C%E7%9A%84%E7%A5%9E%E8%AF%9D%E8%83%8C%E6%99%AF/","tags":[["动漫","/tags/%E5%8A%A8%E6%BC%AB/"],["火影","/tags/%E7%81%AB%E5%BD%B1/"]],"categories":[["动漫","/categories/%E5%8A%A8%E6%BC%AB/"],["火影","/categories/%E5%8A%A8%E6%BC%AB/%E7%81%AB%E5%BD%B1/"]],"content":" 摘要日漫作品中常将本土神话故事结合到作品当中 火影忍者作为一部篇幅较长的连载番其中也不乏此类内容 佐助和鼬 迪达拉 大蛇丸 大筒木辉夜 -佐助和鼬 宇智波家族两大禁术：伊邪那岐与伊邪那美，相传是日本两大创世神，同时也是夫妻。两人所生子皆为神明。伊邪那美在诞下火神加具土命时被其灼热的火焰烧伤，难产而死。（象征鼬为佐助而死）后独自一人的伊邪那岐在去黄泉寻找妻子反被追杀后，以清水洗左眼，诞下天照；以清水洗右眼，诞下月读；以清水洗鼻，诞下须佐之男。（鼬左眼天照，右眼月读）。 -迪达拉原型为天龙八部里的“非人”存在迦楼罗。性情暴躁，状如巨鸟（小迪载具就是粘土巨鸟）。在鼬收迪达拉入伙时，场景为一所寺庙，庙内摆放着佛教八大明王（象征小迪在此处被降伏）。此外，迦楼罗在印度神话里为自焚而亡，对应小迪最终自爆而死；小迪打佐助时释放过“C4：迦楼罗” -大蛇丸原型可能为酒吞童子（百鬼之首）。肤白貌美，有说法称其为白磷大蛇与人类所生之子。白磷大蛇后被伊邪那岐所放逐的须佐之男所杀死（对应鼬十拳剑封印大蛇丸） -辉夜与君麻吕原型皆取自十世纪日本文学作品《竹取物语》（竹取=辉夜）。日本的月之女神叫做“月读”，月读曾因错杀五谷之神，被贬下凡间，下凡的时候她身长只有三寸，躲在竹管之间。 一名樵夫（名为造麻吕，君麻吕名字的来源）路过，找到月读神并与其妻子一齐将其抚养长大，命名为辉夜姬。 天皇与辉夜姬只是偶然一遇，便倾心不已，可他纵然位高权重，也是求见而不得。辉夜姬始终不愿入宫，三年以来，两人只能通过书信慰情。 每当天上出现月亮的时候，辉夜姬就会望月叹息，老樵夫问她因何事哀怨，她也说不上自己为何忧愁，只感到本能地焦虑起来。某次望月的时候辉夜姬突然告诉樵夫，她本是月上之神，被贬下凡间，现刑期将满，下一次的月圆之夜，夜之国的人就要接自己回去。 老樵夫冲进宫去，奏报天皇，请求天皇派兵阻拦月宫之人抢夺辉夜姬。 天皇急忙派遣两千御林军，将老樵夫的宅院团团围住，并且派人守在屋顶，手持弓箭，但见有人自天上来，便将其乱箭射死。 月圆之夜，宅第四周光芒四射，明亮胜于白昼。天人乘云而下，浮悬空中。 一时之间，所有守军四肢酸麻、头脑眩晕。箭矢乱飞、无一射中。 天人质问老樵夫辉夜姬下落，一开始老樵夫说谎想蒙混过关，可是被天人识破 天人便使用法术破开门窗，高歌曰：“汝为月神，此污秽之地，岂可旧居？”辉夜姬心知无可奈何，便淡然走出，服从命运的安排。 天人们便取来箱箧，内有羽衣、灵药。羽衣可升天，灵药可不死。 天人命辉夜姬服药，辉夜姬只略吃一点，余下的偷偷塞给老人，想让养父长生不死，无奈被天人识破：“凡人岂可长生？” 她给老樵夫写了一封信留作思念，信中述说了分别的悲恸以及未能侍奉终老的遗憾。天人又强行令辉夜姬穿上羽衣，可辉夜姬临走之前还有一事不舍，她请求天人多给自己一点时间，天人不允。辉夜姬再求：“此等不近人情，辉夜姬恕难从命” 辉夜姬执意给天皇写了一封信，言明曾经她不能入宫的苦衷，并且附诗曰：“人世难久留，身着羽衣去。忆君情义重，哀书表寸心”。 辉夜姬在写信的时候偷偷将长生不老药塞入信封，交给将军，而后坐上天车、升天而去。归返月宫、重为月神。 辉夜姬走后，老樵夫终日茶饭不思、泣血捶胸，生了一场大病，旁人劝其服药，樵夫只是说：“风烛残年，何必爱命？爱女已去。苟活无益。”不久后，含恨而终。 天皇得知辉夜姬远赴月宫，亦是悲恸万分，生不如死。 某一天，他召集王公大臣问道：“世界上哪一座山离天最近？” 诸臣答曰：“骏河国的山，离京都最近、离天也最近。” 天皇写下诗句：“佳人难再见，心悲泪交流。纵有不死药，服之何所求。” 天皇将诗书连同不死灵药一齐放在山顶、焚烧殆尽。 从此以后，这座山便称为“不死之山”，也叫“富士山”（富士是“不死”的意思） 最主要的，大筒木一族就是居住在月球的神明，火影里也有交代辉夜自月球而来，后被六道老头用地爆天星封印回了月球。此外，斑开启无限月读复活了辉夜也代表了辉夜作为月读女神的身份。 这些只是火影中背后神话的皮毛，感兴趣的可以自己入个深坑 （/滑稽）。个人认为对故事中存在的神话背景加以了解在理解人物关系和分析人物形象时相当于有了参考，在进一步解析作品内涵方面也能有很好的帮助。 参考文章: 《火影忍者》背后的神话传说"}]